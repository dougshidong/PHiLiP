#include "target_functional.h"

namespace PHiLiP {

/** Target boundary values.
 *  Simply zero out the default volume contribution.
 */
template <int dim, int nspecies, int nstate, typename real>
class TargetBoundaryFunctional : public TargetFunctional<dim, nspecies, nstate, real>
{
    using FadType = Sacado::Fad::DFad<real>; ///< Sacado AD type for first derivatives.
    using FadFadType = Sacado::Fad::DFad<FadType>; ///< Sacado AD type that allows 2nd derivatives.

    /// Avoid warning that the function was hidden [-Woverloaded-virtual].
    /** The compiler would otherwise hide Functional::evaluate_volume_integrand, which is fine for 
     *  us, but is a typical bug that other people have. This 'using' imports the base class function
     *  to our derived class even though we don't need it.
     */
    using Functional<dim,nspecies,nstate,real>::evaluate_volume_integrand;

public:
    /// Constructor
    TargetBoundaryFunctional(
        std::shared_ptr<DGBase<dim,nspecies,real>> dg_input,
  const dealii::LinearAlgebra::distributed::Vector<real> &target_solution,
        const bool uses_solution_values = true,
        const bool uses_solution_gradient = false)
 : TargetFunctional<dim,nspecies,nstate,real>(dg_input, target_solution, uses_solution_values, uses_solution_gradient)
 {}

    /// Zero out the default inverse target volume functional.
 template <typename real2>
 real2 evaluate_volume_integrand(
  const PHiLiP::Physics::PhysicsBase<dim,nstate,real2> &/*physics*/,
  const dealii::Point<dim,real2> &/*phys_coord*/,
  const std::array<real2,nstate> &,//soln_at_q,
        const std::array<real,nstate> &,//target_soln_at_q,
  const std::array<dealii::Tensor<1,dim,real2>,nstate> &/*soln_grad_at_q*/,
  const std::array<dealii::Tensor<1,dim,real2>,nstate> &/*target_soln_grad_at_q*/) const
 {
  real2 l2error = 0;
  
  return l2error;
 }

 /// non-template functions to override the template classes
 real evaluate_volume_integrand(
  const PHiLiP::Physics::PhysicsBase<dim,nstate,real> &physics,
  const dealii::Point<dim,real> &phys_coord,
  const std::array<real,nstate> &soln_at_q,
        const std::array<real,nstate> &target_soln_at_q,
  const std::array<dealii::Tensor<1,dim,real>,nstate> &soln_grad_at_q,
  const std::array<dealii::Tensor<1,dim,real>,nstate> &target_soln_grad_at_q) const override
 {
  return evaluate_volume_integrand<>(physics, phys_coord, soln_at_q, target_soln_at_q, soln_grad_at_q, target_soln_grad_at_q);
 }
 /// non-template functions to override the template classes
 FadFadType evaluate_volume_integrand(
  const PHiLiP::Physics::PhysicsBase<dim,nstate,FadFadType> &physics,
  const dealii::Point<dim,FadFadType> &phys_coord,
  const std::array<FadFadType,nstate> &soln_at_q,
        const std::array<real,nstate> &target_soln_at_q,
  const std::array<dealii::Tensor<1,dim,FadFadType>,nstate> &soln_grad_at_q,
        const std::array<dealii::Tensor<1,dim,FadFadType>,nstate> &target_soln_grad_at_q) const override
 {
  return evaluate_volume_integrand<>(physics, phys_coord, soln_at_q, target_soln_at_q, soln_grad_at_q, target_soln_grad_at_q);
 }
};

} // PHiLiP namespace
