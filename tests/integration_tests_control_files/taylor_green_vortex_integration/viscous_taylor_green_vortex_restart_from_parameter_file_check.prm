# Listing of Parameters
# ---------------------
# Convective numerical flux. Choices are <lax_friedrichs | roe | l2roe |
# split_form>.
set conv_num_flux                     = roe                               # default: lax_friedrichs

# Number of dimensions
set dimension                         = 3                                 # default: -1

# Dissipative numerical flux. Choices are <symm_internal_penalty |
# bassi_rebay_2>.
set diss_num_flux                     = symm_internal_penalty

# Flux Reconstruction. Choices are <cDG | cSD | cHU | cNegative | cNegative2 |
# cPlus | cPlus1D | c10Thousand | cHULumped>.
set flux_reconstruction               = cDG

# Flux Reconstruction for Auxiliary Equation. Choices are <kDG | kSD | kHU |
# kNegative | kNegative2 | kPlus | k10Thousand>.
set flux_reconstruction_aux           = kDG

# Type of triangulation to be used.Note: parralel_distributed_triangulation
# not availible int 1D. <default_triangulation |   triangulation |
# parallel_shared_triangulation |  parallel_distributed_triangulation>.
set mesh_type                         = default_triangulation

# Enum of physics models (i.e. model equations and/or terms additional to
# Navier-Stokes or a chosen underlying baseline physics).Choices are
# <large_eddy_simulation>.
set model_type                        = large_eddy_simulation

# Number of extra quadrature points to use.If overintegration=0, then we use
# n_quad = soln_degree + 1.
set overintegration                   = 0

# The PDE we want to solve. Choices are  <advection |   diffusion |
# convection_diffusion |   advection_vector |   burgers_inviscid |
# burgers_viscous |   burgers_rewienski |   euler |   mhd |  navier_stokes |
# physics_model>.
set pde_type                          = navier_stokes                     # default: advection

# Type of run (default is integration_test). Choices are  <integration_test |
# flow_simulation>.
set run_type                          = integration_test

# Scaling of Symmetric Interior Penalty term to ensure coercivity.
set sipg_penalty_factor               = 1.0

# Name of directory for writing solution vtk files. Current directory by
# default.
set solution_vtk_files_directory_name = .

# The type of test we want to solve. Choices are  <run_control |
# grid_refinement_study |   burgers_energy_stability |
# diffusion_exact_adjoint |   optimization_inverse_manufactured |
# euler_gaussian_bump |   euler_gaussian_bump_enthalpy |
# euler_gaussian_bump_adjoint |   euler_cylinder |   euler_cylinder_adjoint |
# euler_vortex |   euler_entropy_waves |   euler_split_taylor_green |
# euler_bump_optimization |   euler_naca_optimization |   shock_1d |
# euler_naca0012 |   reduced_order |  POD_adaptation |
# finite_difference_sensitivity |   advection_periodicity |
# dual_weighted_residual_mesh_adaptation |   taylor_green_vortex_energy_check
# |   taylor_green_vortex_restart_check |   time_refinement_study>.
set test_type                         = taylor_green_vortex_energy_check # default: run_control

# Not calculate L2 norm by default (M+K). Otherwise, get L2 norm per
# iteration.
set use_L2_norm                       = false

# Not use Classical Flux Reconstruction by default. Otherwise, use Classical
# Flux Reconstruction.
set use_classical_Flux_Reconstruction = false

# Use Gauss-Legendre by default. Otherwise, use Gauss-Lobatto to collocate.
set use_collocated_nodes              = false

# Not calculate energy by default. Otherwise, get energy per iteration.
set use_energy                        = false

# Use other boundary conditions by default. Otherwise use periodic (for 1d
# burgers only
set use_periodic_bc                   = true                              # default: false

# Use original form by defualt. Otherwise, split the fluxes.
set use_split_form                    = false

# Use weak form by default. If false, use strong form.
set use_weak_form                     = true


subsection ODE solver
  # Initial desired time for outputting the solution every dt time intervals
  # at which we initialize the ODE solver with.
  set initial_desired_time_for_output_solution_every_dt_time_intervals = 0.0000000000000000e+00

  # Initial iteration at which we initialize the ODE solver with.
  set initial_iteration                                                = 4

  # Initial time at which we initialize the ODE solver with.
  set initial_time                                                     = 6.2831853071795875e-03

  # Time step used in ODE solver.
  set initial_time_step                                                = 1.5707963267948969e-03

  # Maximum nonlinear solver iterations
  set nonlinear_max_iterations                                         = 500000

  # Nonlinear solver residual tolerance
  set nonlinear_steady_residual_tolerance                              = 1e-13

  # State whether output from ODE solver should be printed. Choices are
  # <quiet|verbose>.
  set ode_output                                                       = quiet           # default: verbose

  # Explicit or implicit solver, or reduced-order POD Galerkin or POD Petrov
  # Galerkin solverChoices are
  # <explicit|implicit|pod_galerkin|pod_petrov_galerkin>.
  set ode_solver_type                                                  = explicit        # default: implicit

  # Set as false by default. If true, writes the linear solver convergence
  # data for steady state to a file named
  # 'ode_solver_steady_state_convergence_data_table.txt'.
  set output_ode_solver_steady_state_convergence_table                 = false

  # Outputs the solution at time intervals of dt in .vtk file
  set output_solution_every_dt_time_intervals                          = 0.0

  # Outputs the solution every x steps in .vtk file
  set output_solution_every_x_steps                                    = -1

  # Output final steady state solution. False by default.
  set output_final_steady_state_solution_to_file                       = false

  # Print every print_iteration_modulo iterations of the nonlinear solver
  set print_iteration_modulo                                           = 1

  # Filename to use when outputting final steady state solution
  set steady_state_final_solution_filename                              = solution_snapshot

  # Multiplies initial time-step by
  # time_step_factor_residual*(-log10(residual_norm_decrease)).
  set time_step_factor_residual                                        = 0.0

  # Scales initial time step by
  # pow(time_step_factor_residual*(-log10(residual_norm_decrease)),time_step_factor_residual_exp).
  set time_step_factor_residual_exp                                    = 1.0


  subsection explicit solver options
    # Order for the Runge-Kutta explicit time advancement scheme.Choices are
    # <1|3|4>.
    set runge_kutta_order = 3
  end

end


subsection artificial dissipation
  # Persson's subscell shock capturing artificial dissipation.
  set add_artificial_dissipation       = false

  # Type of artificial dissipation test type we want to implement. Choices are
  # residual_convergence, discontinuity_sensor_activation,
  # poly_order_convergence
  set artificial_dissipation_test_type = poly_order_convergence

  # Type of artificial dissipation we want to implement. Choices are
  # laplacian, physical and enthalpy_conserving_laplacian
  set artificial_dissipation_type      = laplacian

  # Kappa from Persson's subcell shock capturing
  set kappa_artificial_dissipation     = 1.0

  # Mu (viscosity) from Persson's subcell shock capturing.
  set mu_artificial_dissipation        = 1.0

  # By default we calculate the entropy error from the conservative variables.
  # Otherwise, compute the enthalpy error. An example is in Euler Gaussian
  # bump.
  set use_enthalpy_error               = false
end


subsection burgers
  # Viscous Burgers diffusion coefficient
  set diffusion_coefficient           = 0.115572735

  # Burgers Rewienski parameter a
  set rewienski_a                     = 2.2360679775

  # Burgers Rewienski parameter b
  set rewienski_b                     = 0.02

  # Adds the manufactured solution source term to the PDE source term.Set as
  # true for running a manufactured solution.
  set rewienski_manufactured_solution = false
end


subsection euler
  # Angle of attack in degrees. Required for 2D
  set angle_of_attack  = 0.0

  # Gamma gas constant
  set gamma_gas        = 1.4

  # Farfield Mach number
  set mach_infinity    = 0.1 # default: 0.5

  # Reference length for non-dimensionalization.
  set reference_length = 1.0

  # Side slip angle in degrees. Required for 3D
  set side_slip_angle  = 0.0
end


subsection flow_solver
  # Adapt the time step on the fly for unsteady flow simulations. False by
  # default (i.e. constant time step by default).
  set adaptive_time_step                           = false

  # Courant-Friedrich-Lewy (CFL) number for constant time step.
  set courant_friedrich_lewy_number                = 0.003                                              # default: 1

  # Final solution time.
  set final_time                                   = 1.2566370614400000e-02                             # default: 1

  # The type of flow we want to simulate. Choices are  <taylor_green_vortex |
  # burgers_viscous_snapshot |  naca0012 |  burgers_rewienski_snapshot |
  # advection_periodic>.
  set flow_case_type                               = taylor_green_vortex

  # Output restart files for restarting the computation. False by default.
  set output_restart_files                         = true

  # Outputs the restart files at time intervals of dt.
  set output_restart_files_every_dt_time_intervals = 0.0

  # Outputs the restart files every x steps.
  set output_restart_files_every_x_steps           = 1

  # Polynomial order (P) of the basis functions for DG.
  set poly_degree                                  = 2                                                  # default: 1

  # Restarts the computation from the restart file. False by default.
  set restart_computation_from_file                = true

  # Index of restart file from which the computation will be restarted from. 1
  # by default.
  set restart_file_index                           = 4

  # Name of directory for writing and reading restart files. Current directory
  # by default.
  set restart_files_directory_name                 = .

  # Filename for the sensitivity data table output file:
  # sensitivity_table_filename.txt.
  set sensitivity_table_filename                   = sensitivity_table

  # Solve steady-state solution. False by default (i.e. unsteady by default).
  set steady_state                                 = false

  # For steady-state cases, does polynomial ramping if set to true. False by
  # default.
  set steady_state_polynomial_ramping              = false

  # Filename of the unsteady data table output file:
  # unsteady_data_table_filename.txt.
  set unsteady_data_table_filename                 = tgv_kinetic_energy_vs_time_table_for_restart_check # default: unsteady_data_table


  subsection grid
    # Polynomial degree of the grid. Curvilinear grid if set greater than 1;
    # default is 1.
    set grid_degree                           = 1

    # Left bound of domain for hyper_cube mesh based cases.
    set grid_left_bound                       = 0.0

    # Right bound of domain for hyper_cube mesh based cases.
    set grid_right_bound                      = 6.28318530717958623200 # default: 1.0

    # Filename of the input mesh: input_mesh_filename.msh. For cases that
    # import a mesh file.
    set input_mesh_filename                   = naca0012

    # Number of grid elements per dimension for hyper_cube mesh based cases.
    set number_of_grid_elements_per_dimension = 4
  end

  subsection taylor_green_vortex
    # The type of density initialization. Choices are  <uniform |
    # isothermal>.
    set density_initial_condition_type                      = uniform

    # For integration test purposes, expected kinetic energy at final time.
    set expected_kinetic_energy_at_final_time               = 1.2073987162682624e-01 # default: 1

    # For integration test purposes, expected theoretical kinetic energy
    # dissipation rate at final time.
    set expected_theoretical_dissipation_rate_at_final_time = 4.5422264559811485e-04
  end

  subsection time_refinement_study
    # Number of times to run the flow solver during a time refinement study.
    set number_of_times_to_solve = 4

    # Ratio between a timestep size and the next in a time refinement study,
    # 0<r<1.
    set refinement_ratio         = 0.5
  end

end


subsection functional
  # Stores a vector with a list of the (unsigned) integer boundary ID.
  # Formatted in square brackets and seperated by commas, eg. "[0,2]"
  set boundary_vector               = [0, 1]

  # Functional that we want to use. Choice are  <normLp_volume |
  # normLp_boundary |   weighted_integral_volume |
  # weighted_integral_boundary |   error_normLp_volume |
  # error_normLp_boundary>.
  set functional_type               = normLp_volume

  # Lp norm strength (may not be used depending on the functional choice).
  set normLp                        = 2.0

  # Indicates whether all boundaries should be evaluated (for boundary
  # functionals). If set to true (default), overrides the boundary_vector
  # list.
  set use_all_boundaries            = true

  # Indicates whether to use weight function value or laplacian in the
  # functional.
  set use_weight_function_laplacian = false

  # The weight function we want to use (may not be used depending on the
  # functional choice). Choices are  <sine_solution |   cosine_solution |
  # additive_solution |   exp_solution |   poly_solution |
  # even_poly_solution |   atan_solution>.
  set weight_function_type          = exp_solution
end


subsection grid refinement study
  # [0] term of advection vector.
  set advection_0                  = 1.100000

  # [1] term of advection vector.
  set advection_1                  = -1.155727

  # [2] term of advection vector.
  set advection_2                  = 0.865256

  # Indicates whether function is to be approximated from manufactured
  # solutionor exact value read from functional_value parameter.
  set approximate_functional       = false

  # [0,0] term of diffusion tensor.
  set diffusion_00                 = 12.000000

  # [0,1] term of diffusion tensor.
  set diffusion_01                 = 3.000000

  # [0,2] term of diffusion tensor.
  set diffusion_02                 = -2.000000

  # [1,0] term of diffusion tensor.
  set diffusion_10                 = 3.000000

  # [1,1] term of diffusion tensor.
  set diffusion_11                 = 20.000000

  # [1,2] term of diffusion tensor.
  set diffusion_12                 = -5.000000

  # [2,0] term of diffusion tensor.
  set diffusion_20                 = 2.000000

  # [2,1] term of diffusion tensor.
  set diffusion_21                 = 5.000000

  # [2,2] term of diffusion tensor.
  set diffusion_22                 = 18.000000

  # Set the diffusion matrix coefficient.
  set diffusion_coefficient        = 0.115573

  # Exact value of functional for goal-oriented convergence.
  set functional_value             = 0.0

  # for grid_type hypercube, left bound of domain.
  set grid_left                    = 0.0

  # for grid_type hypercube, right bound of domain.
  set grid_right                   = 1.0

  # Initial grid size (number of elements per side).
  set grid_size                    = 4

  # Enum of generated grid. If read_grid, must have grids xxxx.msh.Choices are
  # <hypercube|read_grid>.
  set grid_type                    = hypercube

  # Name of Gmsh grid xxxx.msh used in the grid refinement study if read_grid
  # is chosen as the grid_type.
  set input_grid                   = xxxx

  # The manufactured solution we want to use (if
  # use_manufactured_source_term==true). Choices are  <sine_solution |
  # zero_solution |   cosine_solution |   additive_solution |   exp_solution |
  # poly_solution |   even_poly_solution |   atan_solution |
  # boundary_layer_solution |   s_shock_solution |   quadratic_solution |
  # navah_solution_1 |   navah_solution_2 |   navah_solution_3 |
  # navah_solution_4 |   navah_solution_5>.
  set manufactured_solution_type   = exp_solution

  # Number of different refinements to be performed.
  set num_refinements              = 0

  # Output flag for wall clock adjoint timing.
  set output_adjoint_time          = false

  # output flag for adjoint vtk files.
  set output_adjoint_vtk           = false

  # ouput the convergence table for the functional error.
  set output_functional_error      = false

  # Output flag for gnuplot functional error figure.
  set output_gnuplot_functional    = false

  # Output flag for gnuplot solution error figure.
  set output_gnuplot_solution      = true

  # ouput the convergence table for the solution error.
  set output_solution_error        = true

  # Output flag for wall clock solution timing.
  set output_solution_time         = false

  # Output flag for grid_refinement vtk files.
  set output_vtk                   = true

  # Polynomial order of starting mesh.
  set poly_degree                  = 1

  # Polynomial degree of the grid.
  set poly_degree_grid             = 2

  # Maximum polynomial order.
  set poly_degree_max              = 5

  # Indicates whetherto output a new gnuplot figure at every
  # iteration.Requires output_gnuplot == true.
  set refresh_gnuplot              = true

  # Indicates whether to interpolate the problem instead of solving with DG.
  set use_interpolation            = false

  # Uses non-zero source term based on the manufactured solution and the PDE.
  set use_manufactured_source_term = false


  subsection functional
    # Stores a vector with a list of the (unsigned) integer boundary ID.
    # Formatted in square brackets and seperated by commas, eg. "[0,2]"
    set boundary_vector               = [0, 1]

    # Functional that we want to use. Choice are  <normLp_volume |
    # normLp_boundary |   weighted_integral_volume |
    # weighted_integral_boundary |   error_normLp_volume |
    # error_normLp_boundary>.
    set functional_type               = normLp_volume

    # Lp norm strength (may not be used depending on the functional choice).
    set normLp                        = 2.0

    # Indicates whether all boundaries should be evaluated (for boundary
    # functionals). If set to true (default), overrides the boundary_vector
    # list.
    set use_all_boundaries            = true

    # Indicates whether to use weight function value or laplacian in the
    # functional.
    set use_weight_function_laplacian = false

    # The weight function we want to use (may not be used depending on the
    # functional choice). Choices are  <sine_solution |   cosine_solution |
    # additive_solution |   exp_solution |   poly_solution |
    # even_poly_solution |   atan_solution>.
    set weight_function_type          = exp_solution
  end

  subsection grid refinement
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [0]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [1]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [2]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [3]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [4]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [5]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [6]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [7]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [8]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [9]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

end


subsection linear solver
  # State whether output from linear solver should be printed. Choices are
  # <quiet|verbose>.
  set linear_solver_output = quiet

  # Enum of linear solverChoices are <direct|gmres>.
  set linear_solver_type   = gmres


  subsection gmres options
    # Factor by which the diagonal of the matrix will be scaled, which
    # sometimes can help to get better preconditioners
    set ilut_atol                 = 0.0

    # relative size of elements which should be dropped when forming an
    # incomplete lu decomposition with threshold
    set ilut_drop                 = 0.0

    # Amount of additional fill-in elements besides the sparse matrix
    # structure.For ilut_fill >= 1.0, Number of entries to keep in the strict
    # upper triangle of the  current row, and in the strict lower triangle of
    # the current  row.  It does NOT correspond to the $p$ parameter in Saad's
    # original.  description. This parameter represents a maximum fill
    # fraction.  In this implementation, the L and U factors always contains
    # nonzeros corresponding  to the original sparsity pattern of A, so this
    # value should be >= 1.0.  Letting $fill = rac{(level-of-fill -
    # 1)*nnz(A)}{2*N}$,  each row of the computed L and U factors contains at
    # most $fill$  nonzero elements in addition to those from the sparsity
    # pattern of A. For ilut_fill >= 1.0,  Typical graph-based level of-fill
    # of the factorization such that the pattern corresponds to A^(p+1).
    set ilut_fill                 = 1

    # Amount of an absolute perturbation that will be added to the diagonal of
    # the matrix, which sometimes can help to get better preconditioners
    set ilut_rtol                 = 1.0

    # Linear residual tolerance for convergence of the linear system
    set linear_residual_tolerance = 1e-4

    # Maximum number of iterations for linear solver
    set max_iterations            = 1000

    # Number of iterations before restarting GMRES
    set restart_number            = 30
  end

end


subsection manufactured solution convergence study
  # Adds the soln_L2_error of each state to the convergence table.Field names
  # are soln_L2_error_state_istate, where istate=[0,1,...,nstate-1]
  set add_statewise_solution_error_to_convergence_tables = false

  # [0] term of advection vector.
  set advection_0                                        = 1.100000

  # [1] term of advection vector.
  set advection_1                                        = -1.155727

  # [2] term of advection vector.
  set advection_2                                        = 0.865256

  # Last degree used for convergence study
  set degree_end                                         = 3

  # Starting degree for convergence study
  set degree_start                                       = 0

  # [0,0] term of diffusion tensor.
  set diffusion_00                                       = 12.000000

  # [0,1] term of diffusion tensor.
  set diffusion_01                                       = 3.000000

  # [0,2] term of diffusion tensor.
  set diffusion_02                                       = -2.000000

  # [1,0] term of diffusion tensor.
  set diffusion_10                                       = 3.000000

  # [1,1] term of diffusion tensor.
  set diffusion_11                                       = 20.000000

  # [1,2] term of diffusion tensor.
  set diffusion_12                                       = -5.000000

  # [2,0] term of diffusion tensor.
  set diffusion_20                                       = 2.000000

  # [2,1] term of diffusion tensor.
  set diffusion_21                                       = 5.000000

  # [2,2] term of diffusion tensor.
  set diffusion_22                                       = 18.000000

  # Set the diffusion matrix coefficient.
  set diffusion_coefficient                              = 0.115573

  # Multiplier on grid size. ith-grid will be of size
  # (initial_grid*(i*grid_progression)+(i*grid_progression_add))^dim
  set grid_progression                                   = 1.5

  # Adds number of cell to 1D grid. ith-grid will be of size
  # (initial_grid*(i*grid_progression)+(i*grid_progression_add))^dim
  set grid_progression_add                               = 0

  # Enum of generated grid. If read_grid, must have grids xxxx#.msh, where #
  # is the grid numbering from 0 to number_of_grids-1.Choices are
  # <hypercube|sinehypercube|read_grid>.
  set grid_type                                          = hypercube

  # Initial grid of size (initial_grid_size)^dim
  set initial_grid_size                                  = 2

  # Prefix of Gmsh grids xxxx#.msh used in the grid convergence if read_grid
  # is chosen as the grid_type.
  set input_grids                                        = xxxx

  # The manufactured solution we want to use (if
  # use_manufactured_source_term==true). Choices are  <sine_solution |
  # zero_solution |   cosine_solution |   additive_solution |   exp_solution |
  # poly_solution |   even_poly_solution |   atan_solution |
  # boundary_layer_solution |   s_shock_solution |   quadratic_solution |
  # navah_solution_1 |   navah_solution_2 |   navah_solution_3 |
  # navah_solution_4 |   navah_solution_5>.
  set manufactured_solution_type                         = exp_solution

  # Number of grids in grid study
  set number_of_grids                                    = 4

  # Writes the convergence tables for each polynomial degree p.Output will be
  # txt files named
  # convergence_table_[dim]d_[pde_string]_[conv_num_flux_string]_[diss_num_flux_string]_[manufactured_solution_string]_p[poly_degree].txt
  set output_convergence_tables                          = false

  # Writes out meshes used for the simulation.Output will be Gmsh grids named
  # grid-#.msh
  set output_meshes                                      = false

  # Writes the solution files.Output will be vtu and pvtu files.
  set output_solution                                    = false

  # Randomly disturb grid.Displaces node by percentage of longest associated
  # edge.
  set random_distortion                                  = 0.0

  # Tolerance within which the convergence orders are considered to be
  # optimal.
  set slope_deficit_tolerance                            = 0.1

  # Uses non-zero source term based on the manufactured solution and the PDE.
  set use_manufactured_source_term                       = false
end


subsection mesh adaptation
  # Critical residual below which adaptation begins.
  set critical_residual                 = 1.0e-9

  # Fraction of cells to be h-coarsened.
  set h_coarsen_fraction                = 0.0

  # Fraction of cells to be h-refined.
  set h_refine_fraction                 = 0.0

  # Fraction of cells to be p-coarsened.
  set p_coarsen_fraction                = 0.0

  # Fraction of cells to be p-refined.
  set p_refine_fraction                 = 0.0

  # Maximum adaptation steps for a problem.
  set total_refinement_cycles           = 0

  # Flag to use goal oriented mesh adaptation. False by default.
  set use_goal_oriented_mesh_adaptation = false
end


subsection navier_stokes
  # Nondimensionalized isothermal wall temperature.
  set nondimensionalized_isothermal_wall_temperature = 1.0

  # Prandlt number
  set prandtl_number                                 = 0.71      # default: 0.72

  # Farfield Reynolds number
  set reynolds_number_inf                            = 1600.0    # default: 10000000.0

  # Type of thermal boundary conditions to be imposed. Choices are
  # <adiabatic|isothermal>.
  set thermal_boundary_condition_type                = adiabatic
end


subsection physics_model
  subsection large_eddy_simulation
    # Enum of sub-grid scale models.Choices are  <smagorinsky |
    # wall_adaptive_local_eddy_viscosity |   vreman>.
    set SGS_model_type                     = smagorinsky

    # WALE (Wall-Adapting Local Eddy-viscosity) eddy viscosity model constant
    # (default is 0.6)
    set WALE_model_constant                = 0.6

    # Set as false by default (i.e. Navier-Stokes is the baseline physics). If
    # true, sets the baseline physics to the Euler equations.
    set euler_turbulence                   = false

    # Ratio of the large eddy simulation filter width to the cell size
    # (default is 1)
    set ratio_of_filter_width_to_cell_size = 1.0

    # Smagorinsky model constant (default is 0.1)
    set smagorinsky_model_constant         = 0.1

    # Turbulent Prandlt number (default is 0.6)
    set turbulent_prandtl_number           = 0.6

    # Vreman eddy viscosity model constant (default is 0.025)
    set vreman_model_constant              = 0.025
  end

end


subsection reduced order
  # Tolerance for POD adaptation
  set adaptation_tolerance         = 1

  # Path to search for saved snapshots or POD basis.
  set path_to_search               = .
end


