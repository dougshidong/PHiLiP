# Listing of Parameters
# ---------------------
# Convective numerical flux. Choices are <lax_friedrichs | roe | l2roe |
# split_form>.
set conv_num_flux                     = roe                               # default: lax_friedrichs

# Number of dimensions
set dimension                         = 3                                 # default: -1

# Dissipative numerical flux. Choices are <symm_internal_penalty |
# bassi_rebay_2>.
set diss_num_flux                     = symm_internal_penalty

# Flux Reconstruction. Choices are <cDG | cSD | cHU | cNegative | cNegative2 |
# cPlus | cPlus1D | c10Thousand | cHULumped>.
set flux_reconstruction               = cDG

# Flux Reconstruction for Auxiliary Equation. Choices are <kDG | kSD | kHU |
# kNegative | kNegative2 | kPlus | k10Thousand>.
set flux_reconstruction_aux           = kDG

# Type of triangulation to be used.Note: parralel_distributed_triangulation
# not availible int 1D. <default_triangulation |   triangulation |
# parallel_shared_triangulation |  parallel_distributed_triangulation>.
set mesh_type                         = default_triangulation

# Number of extra quadrature points to use.If overintegration=0, then we use
# n_quad = soln_degree + 1.
set overintegration                   = 0

# The PDE we want to solve. Choices are  <advection |   diffusion |
# convection_diffusion |   advection_vector |   burgers_inviscid |
# burgers_viscous |   burgers_rewienski |   euler |   mhd |  navier_stokes>.
set pde_type                          = navier_stokes                     # default: advection

# Scaling of Symmetric Interior Penalty term to ensure coercivity.
set sipg_penalty_factor               = 1.0

# The type of test we want to solve. Choices are (only run control has been
# coded up for now) <run_control |   grid_refinement_study |
# burgers_energy_stability |   diffusion_exact_adjoint |
# optimization_inverse_manufactured |   euler_gaussian_bump |
# euler_gaussian_bump_enthalpy |   euler_gaussian_bump_adjoint |
# euler_cylinder |   euler_cylinder_adjoint |   euler_vortex |
# euler_entropy_waves |   euler_split_taylor_green |  euler_bump_optimization
# |   euler_naca_optimization |   shock_1d |   euler_naca0012 |
# reduced_order |  POD_adaptation |  finite_difference_sensitivity |
# advection_periodicity |   flow_solver |
# dual_weighted_residual_mesh_adaptation |   taylor_green_vortex_energy_check
# |   taylor_green_vortex_restart_check>.
set test_type                         = taylor_green_vortex_energy_check # default: run_control

# Not calculate L2 norm by default (M+K). Otherwise, get L2 norm per
# iteration.
set use_L2_norm                       = false

# Not use Classical Flux Reconstruction by default. Otherwise, use Classical
# Flux Reconstruction.
set use_classical_Flux_Reconstruction = false

# Use Gauss-Legendre by default. Otherwise, use Gauss-Lobatto to collocate.
set use_collocated_nodes              = false

# Not calculate energy by default. Otherwise, get energy per iteration.
set use_energy                        = false

# Use other boundary conditions by default. Otherwise use periodic (for 1d
# burgers only
set use_periodic_bc                   = true                              # default: false

# Use original form by defualt. Otherwise, split the fluxes.
set use_split_form                    = false

# Use weak form by default. If false, use strong form.
set use_weak_form                     = true


subsection ODE solver
  # Initial desired time for outputting the solution every dt time intervals
  # at which we initialize the ODE solver with.
  set initial_desired_time_for_output_solution_every_dt_time_intervals = 0.0000000000000000e+00

  # Initial iteration at which we initialize the ODE solver with.
  set initial_iteration                                                = 4

  # Initial time at which we initialize the ODE solver with.
  set initial_time                                                     = 6.1240484302437529e-03

  # Time step used in ODE solver.
  set initial_time_step                                                = 1.5310121075609382e-03

  # Maximum nonlinear solver iterations
  set nonlinear_max_iterations                                         = 500000

  # Nonlinear solver residual tolerance
  set nonlinear_steady_residual_tolerance                              = 1e-13

  # State whether output from ODE solver should be printed. Choices are
  # <quiet|verbose>.
  set ode_output                                                       = quiet           # default: verbose

  # Explicit or implicit solver, or reduced-order POD Galerkin or POD Petrov
  # Galerkin solverChoices are
  # <explicit|implicit|pod_galerkin|pod_petrov_galerkin>.
  set ode_solver_type                                                  = explicit        # default: implicit

  # Outputs the solution at time intervals of dt in .vtk file
  set output_solution_every_dt_time_intervals                          = 0.0

  # Outputs the solution every x steps in .vtk file
  set output_solution_every_x_steps                                    = -1

  # Output solution vector every output_solution_vector_modulo iterations of
  # the nonlinear solver. Set to 0 to disable.
  set output_solution_vector_modulo                                    = 0

  # Print every print_iteration_modulo iterations of the nonlinear solver
  set print_iteration_modulo                                           = 1

  # Filename to use when outputting solution vectors in a table format.
  set solutions_table_filename                                         = solutions_table

  # Multiplies initial time-step by
  # time_step_factor_residual*(-log10(residual_norm_decrease)).
  set time_step_factor_residual                                        = 0.0

  # Scales initial time step by
  # pow(time_step_factor_residual*(-log10(residual_norm_decrease)),time_step_factor_residual_exp).
  set time_step_factor_residual_exp                                    = 1.0


  subsection explicit solver options
    # Order for the Runge-Kutta explicit time advancement scheme.Choices are
    # <1|3|4>.
    set runge_kutta_order = 3
  end

end


subsection artificial dissipation
  # Persson's subscell shock capturing artificial dissipation.
  set add_artificial_dissipation       = false

  # Type of artificial dissipation test type we want to implement. Choices are
  # residual_convergence, discontinuity_sensor_activation,
  # poly_order_convergence
  set artificial_dissipation_test_type = poly_order_convergence

  # Type of artificial dissipation we want to implement. Choices are
  # laplacian, physical and enthalpy_conserving_laplacian
  set artificial_dissipation_type      = laplacian

  # Kappa from Persson's subcell shock capturing
  set kappa_artificial_dissipation     = 1.0

  # Mu (viscosity) from Persson's subcell shock capturing.
  set mu_artificial_dissipation        = 1.0

  # By default we calculate the entropy error from the conservative variables.
  # Otherwise, compute the enthalpy error. An example is in Euler Gaussian
  # bump.
  set use_enthalpy_error               = false
end


subsection burgers
  # Viscous Burgers diffusion coefficient
  set diffusion_coefficient           = 0.115572735

  # Burgers Rewienski parameter a
  set rewienski_a                     = 2.2360679775

  # Burgers Rewienski parameter b
  set rewienski_b                     = 0.02

  # Adds the manufactured solution source term to the PDE source term.Set as
  # true for running a manufactured solution.
  set rewienski_manufactured_solution = false
end


subsection euler
  # Angle of attack in degrees. Required for 2D
  set angle_of_attack  = 0.0

  # Gamma gas constant
  set gamma_gas        = 1.4

  # Farfield Mach number
  set mach_infinity    = 0.1 # default: 0.5

  # Reference length for non-dimensionalization.
  set reference_length = 1.0

  # Side slip angle in degrees. Required for 3D
  set side_slip_angle  = 0.0
end


subsection flow_solver
  # Courant-Friedrich-Lewy (CFL) number for constant time step.
  set courant_friedrich_lewy_number = 0.005                                              # default: 1

  # Final solution time.
  set final_time                    = 1.2248096860487504e-02                             # default: 1

  # The type of flow we want to simulate. Choices are  <taylor_green_vortex |
  # burgers_viscous_snapshot |  burgers_rewienski_snapshot>.
  set flow_case_type                = taylor_green_vortex

  # Output restart files for restarting the computation. False by default.
  set output_restart_files          = true

  # Restarts the computation from the restart file. False by default.
  set restart_computation_from_file = true

  # Index of restart file from which the computation will be restarted from. 0
  # by default.
  set restart_file_index            = 4

  # Filename for the sensitivity data table output file:
  # sensitivity_table_filename.txt.
  set sensitivity_table_filename    = sensitivity_table

  # Solve steady-state solution. False by default.
  set steady_state                  = false

  # Filename for of the unsteady data table output file:
  # unsteady_data_table_filename.txt.
  set unsteady_data_table_filename  = tgv_kinetic_energy_vs_time_table_for_restart_check # default: unsteady_data_table


  subsection taylor_green_vortex
    # For integration test purposes, expected kinetic energy at final time.
    set expected_kinetic_energy_at_final_time = 1.2074066465958100e-01 # default: 1
  end

end


subsection functional
  # Stores a vector with a list of the (unsigned) integer boundary ID.
  # Formatted in square brackets and seperated by commas, eg. "[0,2]"
  set boundary_vector               = [0, 1]

  # Functional that we want to use. Choice are  <normLp_volume |
  # normLp_boundary |   weighted_integral_volume |
  # weighted_integral_boundary |   error_normLp_volume |
  # error_normLp_boundary>.
  set functional_type               = normLp_volume

  # Lp norm strength (may not be used depending on the functional choice).
  set normLp                        = 2.0

  # Indicates whether all boundaries should be evaluated (for boundary
  # functionals). If set to true (default), overrides the boundary_vector
  # list.
  set use_all_boundaries            = true

  # Indicates whether to use weight function value or laplacian in the
  # functional.
  set use_weight_function_laplacian = false

  # The weight function we want to use (may not be used depending on the
  # functional choice). Choices are  <sine_solution |   cosine_solution |
  # additive_solution |   exp_solution |   poly_solution |
  # even_poly_solution |   atan_solution>.
  set weight_function_type          = exp_solution
end


subsection grid refinement study
  # [0] term of advection vector.
  set advection_0                  = 1.100000

  # [1] term of advection vector.
  set advection_1                  = -1.155727

  # [2] term of advection vector.
  set advection_2                  = 0.865256

  # Indicates whether function is to be approximated from manufactured
  # solutionor exact value read from functional_value parameter.
  set approximate_functional       = false

  # [0,0] term of diffusion tensor.
  set diffusion_00                 = 12.000000

  # [0,1] term of diffusion tensor.
  set diffusion_01                 = 3.000000

  # [0,2] term of diffusion tensor.
  set diffusion_02                 = -2.000000

  # [1,0] term of diffusion tensor.
  set diffusion_10                 = 3.000000

  # [1,1] term of diffusion tensor.
  set diffusion_11                 = 20.000000

  # [1,2] term of diffusion tensor.
  set diffusion_12                 = -5.000000

  # [2,0] term of diffusion tensor.
  set diffusion_20                 = 2.000000

  # [2,1] term of diffusion tensor.
  set diffusion_21                 = 5.000000

  # [2,2] term of diffusion tensor.
  set diffusion_22                 = 18.000000

  # Set the diffusion matrix coefficient.
  set diffusion_coefficient        = 0.115573

  # Exact value of functional for goal-oriented convergence.
  set functional_value             = 0.0

  # for grid_type hypercube, left bound of domain.
  set grid_left                    = 0.0

  # for grid_type hypercube, right bound of domain.
  set grid_right                   = 6.2831853072 # default: 1.0

  # Initial grid size (number of elements per side).
  set grid_size                    = 4

  # Enum of generated grid. If read_grid, must have grids xxxx.msh.Choices are
  # <hypercube|read_grid>.
  set grid_type                    = hypercube

  # Name of Gmsh grid xxxx.msh used in the grid refinement study if read_grid
  # is chosen as the grid_type.
  set input_grid                   = xxxx

  # The manufactured solution we want to use (if
  # use_manufactured_source_term==true). Choices are  <sine_solution |
  # zero_solution |   cosine_solution |   additive_solution |   exp_solution |
  # poly_solution |   even_poly_solution |   atan_solution |
  # boundary_layer_solution |   s_shock_solution |   quadratic_solution |
  # navah_solution_1 |   navah_solution_2 |   navah_solution_3 |
  # navah_solution_4 |   navah_solution_5>.
  set manufactured_solution_type   = exp_solution

  # Number of different refinements to be performed.
  set num_refinements              = 0

  # Output flag for wall clock adjoint timing.
  set output_adjoint_time          = false

  # output flag for adjoint vtk files.
  set output_adjoint_vtk           = false

  # ouput the convergence table for the functional error.
  set output_functional_error      = false

  # Output flag for gnuplot functional error figure.
  set output_gnuplot_functional    = false

  # Output flag for gnuplot solution error figure.
  set output_gnuplot_solution      = true

  # ouput the convergence table for the solution error.
  set output_solution_error        = true

  # Output flag for wall clock solution timing.
  set output_solution_time         = false

  # Output flag for grid_refinement vtk files.
  set output_vtk                   = true

  # Polynomial order of starting mesh.
  set poly_degree                  = 2            # default: 1

  # Polynomial degree of the grid.
  set poly_degree_grid             = 2

  # Maximum polynomial order.
  set poly_degree_max              = 5

  # Indicates whetherto output a new gnuplot figure at every
  # iteration.Requires output_gnuplot == true.
  set refresh_gnuplot              = true

  # Indicates whether to interpolate the problem instead of solving with DG.
  set use_interpolation            = false

  # Uses non-zero source term based on the manufactured solution and the PDE.
  set use_manufactured_source_term = false


  subsection functional
    # Stores a vector with a list of the (unsigned) integer boundary ID.
    # Formatted in square brackets and seperated by commas, eg. "[0,2]"
    set boundary_vector               = [0, 1]

    # Functional that we want to use. Choice are  <normLp_volume |
    # normLp_boundary |   weighted_integral_volume |
    # weighted_integral_boundary |   error_normLp_volume |
    # error_normLp_boundary>.
    set functional_type               = normLp_volume

    # Lp norm strength (may not be used depending on the functional choice).
    set normLp                        = 2.0

    # Indicates whether all boundaries should be evaluated (for boundary
    # functionals). If set to true (default), overrides the boundary_vector
    # list.
    set use_all_boundaries            = true

    # Indicates whether to use weight function value or laplacian in the
    # functional.
    set use_weight_function_laplacian = false

    # The weight function we want to use (may not be used depending on the
    # functional choice). Choices are  <sine_solution |   cosine_solution |
    # additive_solution |   exp_solution |   poly_solution |
    # even_poly_solution |   atan_solution>.
    set weight_function_type          = exp_solution
  end

  subsection grid refinement
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [0]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [1]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [2]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

  subsection grid refinement [3]
    # Inidcates whether the refinement should be done anisotropically.
    set anisotropic                 = false

    # Enum of anisotropic indicators (unused for isotropic refinement).Choices
    # are  <jump_based |   reconstruction_based>.
    set anisotropic_indicator       = jump_based

    # maximum anisotropic ratio for continuous size field targets.
    set anisotropic_ratio_max       = 1.0e+12

    # miniumum anistropic ratio for continuous size field targets.
    set anisotropic_ratio_min       = 1.0e-12

    # Threshold for flagging cells with anisotropic refinement.
    set anisotropic_threshold_ratio = 3.0

    # Maximum coarsening factor for adjoint-based size-field (from log DWR).
    set c_max                       = 4

    # Fraction of elements to undergo coarsening for fixed_fraction method.
    set coarsening_fraction         = 0.03

    # Constant added to the complexity at each step.
    set complexity_add              = 0.0

    # Scaling factor multiplying previous complexity.
    set complexity_scale            = 2.0

    # Stores an initial vector of values for complexity targets. Will iterate
    # over and then switch to scaling and adding. Formatted in square brackets
    # and seperated by commas, eg. "[1000,2000]"
    set complexity_vector           = []

    # Enum of error indicators (unused for uniform refinement).Choices are
    # <error_based |   hessian_based |   residual_based |   adjoint_based>.
    set error_indicator             = error_based

    # Option to exit after call to the grid refinement (for debugging mesh
    # write).
    set exit_after_refine           = false

    # Degree of q for use in the Lq norm of some indicators.
    set norm_Lq                     = 2.0

    # Enum of output data types of refinement indicator (used for msh_out only
    # currently).Choices are  <size_field |   frame_field |   metric_field>.
    set output_data_type            = size_field

    # Enum of output data types (for interface with mesh generators).Choices
    # are  <gmsh_out |   msh_out>.
    set output_type                 = msh_out

    # Maximum refinement factor for adjoint-based size-field (from log DWR).
    set r_max                       = 20

    # Fraction of elements to undergo refinement for fixed_fraction method.
    set refinement_fraction         = 0.3

    # Enum of refinement methods.Choices are  <uniform |   fixed_fraction |
    # continuous>.
    set refinement_method           = uniform

    # Number of iterations to be performed
    set refinement_steps            = 3

    # Enum of refinement types.Choices are  <h |   p |   hp>.
    set refinement_type             = h
  end

end


subsection linear solver
  # State whether output from linear solver should be printed. Choices are
  # <quiet|verbose>.
  set linear_solver_output = quiet

  # Enum of linear solverChoices are <direct|gmres>.
  set linear_solver_type   = gmres


  subsection gmres options
    # Factor by which the diagonal of the matrix will be scaled, which
    # sometimes can help to get better preconditioners
    set ilut_atol                 = 0.0

    # relative size of elements which should be dropped when forming an
    # incomplete lu decomposition with threshold
    set ilut_drop                 = 0.0

    # Amount of additional fill-in elements besides the sparse matrix
    # structure.For ilut_fill >= 1.0, Number of entries to keep in the strict
    # upper triangle of the  current row, and in the strict lower triangle of
    # the current  row.  It does NOT correspond to the $p$ parameter in Saad's
    # original.  description. This parameter represents a maximum fill
    # fraction.  In this implementation, the L and U factors always contains
    # nonzeros corresponding  to the original sparsity pattern of A, so this
    # value should be >= 1.0.  Letting $fill = rac{(level-of-fill -
    # 1)*nnz(A)}{2*N}$,  each row of the computed L and U factors contains at
    # most $fill$  nonzero elements in addition to those from the sparsity
    # pattern of A. For ilut_fill >= 1.0,  Typical graph-based level of-fill
    # of the factorization such that the pattern corresponds to A^(p+1).
    set ilut_fill                 = 1

    # Amount of an absolute perturbation that will be added to the diagonal of
    # the matrix, which sometimes can help to get better preconditioners
    set ilut_rtol                 = 1.0

    # Linear residual tolerance for convergence of the linear system
    set linear_residual_tolerance = 1e-4

    # Maximum number of iterations for linear solver
    set max_iterations            = 1000

    # Number of iterations before restarting GMRES
    set restart_number            = 30
  end

end


subsection manufactured solution convergence study
  # Adds the soln_L2_error of each state to the convergence table.Field names
  # are soln_L2_error_state_istate, where istate=[0,1,...,nstate-1]
  set add_statewise_solution_error_to_convergence_tables = false

  # [0] term of advection vector.
  set advection_0                                        = 1.100000

  # [1] term of advection vector.
  set advection_1                                        = -1.155727

  # [2] term of advection vector.
  set advection_2                                        = 0.865256

  # Last degree used for convergence study
  set degree_end                                         = 3

  # Starting degree for convergence study
  set degree_start                                       = 0

  # [0,0] term of diffusion tensor.
  set diffusion_00                                       = 12.000000

  # [0,1] term of diffusion tensor.
  set diffusion_01                                       = 3.000000

  # [0,2] term of diffusion tensor.
  set diffusion_02                                       = -2.000000

  # [1,0] term of diffusion tensor.
  set diffusion_10                                       = 3.000000

  # [1,1] term of diffusion tensor.
  set diffusion_11                                       = 20.000000

  # [1,2] term of diffusion tensor.
  set diffusion_12                                       = -5.000000

  # [2,0] term of diffusion tensor.
  set diffusion_20                                       = 2.000000

  # [2,1] term of diffusion tensor.
  set diffusion_21                                       = 5.000000

  # [2,2] term of diffusion tensor.
  set diffusion_22                                       = 18.000000

  # Set the diffusion matrix coefficient.
  set diffusion_coefficient                              = 0.115573

  # Multiplier on grid size. ith-grid will be of size
  # (initial_grid*(i*grid_progression)+(i*grid_progression_add))^dim
  set grid_progression                                   = 1.5

  # Adds number of cell to 1D grid. ith-grid will be of size
  # (initial_grid*(i*grid_progression)+(i*grid_progression_add))^dim
  set grid_progression_add                               = 0

  # Enum of generated grid. If read_grid, must have grids xxxx#.msh, where #
  # is the grid numbering from 0 to number_of_grids-1.Choices are
  # <hypercube|sinehypercube|read_grid>.
  set grid_type                                          = hypercube

  # Initial grid of size (initial_grid_size)^dim
  set initial_grid_size                                  = 2

  # Prefix of Gmsh grids xxxx#.msh used in the grid convergence if read_grid
  # is chosen as the grid_type.
  set input_grids                                        = xxxx

  # The manufactured solution we want to use (if
  # use_manufactured_source_term==true). Choices are  <sine_solution |
  # zero_solution |   cosine_solution |   additive_solution |   exp_solution |
  # poly_solution |   even_poly_solution |   atan_solution |
  # boundary_layer_solution |   s_shock_solution |   quadratic_solution |
  # navah_solution_1 |   navah_solution_2 |   navah_solution_3 |
  # navah_solution_4 |   navah_solution_5>.
  set manufactured_solution_type                         = exp_solution

  # Number of grids in grid study
  set number_of_grids                                    = 4

  # Writes the convergence tables for each polynomial degree p.Output will be
  # txt files named
  # convergence_table_[dim]d_[pde_string]_[conv_num_flux_string]_[diss_num_flux_string]_[manufactured_solution_string]_p[poly_degree].txt
  set output_convergence_tables                          = false

  # Writes out meshes used for the simulation.Output will be Gmsh grids named
  # grid-#.msh
  set output_meshes                                      = false

  # Writes the solution files.Output will be vtu and pvtu files.
  set output_solution                                    = false

  # Randomly disturb grid.Displaces node by percentage of longest associated
  # edge.
  set random_distortion                                  = 0.0

  # Tolerance within which the convergence orders are considered to be
  # optimal.
  set slope_deficit_tolerance                            = 0.1

  # Uses non-zero source term based on the manufactured solution and the PDE.
  set use_manufactured_source_term                       = false
end


subsection mesh adaptation
  # Critical residual below which adaptation begins.
  set critical_residual                 = 1.0e-9

  # Fraction of cells to be h-coarsened.
  set h_coarsen_fraction                = 0.0

  # Fraction of cells to be h-refined.
  set h_refine_fraction                 = 0.0

  # Fraction of cells to be p-coarsened.
  set p_coarsen_fraction                = 0.0

  # Fraction of cells to be p-refined.
  set p_refine_fraction                 = 0.0

  # Maximum adaptation steps for a problem.
  set total_refinement_cycles           = 0

  # Flag to use goal oriented mesh adaptation. False by default.
  set use_goal_oriented_mesh_adaptation = false
end


subsection navier_stokes
  # Prandlt number
  set prandtl_number      = 0.71   # default: 0.72

  # Farfield Reynolds number
  set reynolds_number_inf = 1600.0 # default: 10000000.0
end


subsection reduced order
  # Number of basis functions to add to coarse basis at each adaptation
  # iteration. Set to 0 to turn off.
  set adapt_coarse_basis_constant  = 0

  # Tolerance for POD adaptation
  set adaptation_tolerance         = 1

  # Initial dimension of the coarse POD basis
  set coarse_basis_dimension       = 0

  # Consider the sign of the error estimate from the dual-weighted residual.
  # False by default.
  set consider_error_sign          = false

  # Initial dimension of the expanded POD basis
  set expanded_basis_dimension     = 0

  # Initial dimension of the extrapolated POD basis
  set extrapolated_basis_dimension = 0

  # Change in parameter from base parameter value
  set extrapolated_parameter_delta = 0.0

  # Initial dimension of the fine POD basis
  set fine_basis_dimension         = 0

  # Use the method of snapshots to compute the POD basis. False by default.
  set method_of_snapshots          = false

  # Path to search for saved snapshots or POD basis.
  set path_to_search               = .
end


